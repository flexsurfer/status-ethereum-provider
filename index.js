export default function(bridgeSend){
    var callbackId = 0;
    var callbacks = {};
    var statusAppcurrentAccountAddress;

    function sendAPIrequest(permission, params) {
        var messageId = callbackId++;
        var params = params || {};

        bridgeSend({
            type: 'api-request',
            permission: permission,
            messageId: messageId,
            params: params
        });

        return new Promise(function (resolve, reject) {
            params['resolve'] = resolve;
            params['reject'] = reject;
            callbacks[messageId] = params;
        });
    }

    function Unauthorized() {
      this.name = "Unauthorized";
      this.id = 4100;
      this.code = 4100;
      this.message = "The requested method and/or account has not been authorized by the user.";
    }
    Unauthorized.prototype = Object.create(Error.prototype);

    function UserRejectedRequest() {
      this.name = "UserRejectedRequest";
      this.id = 4001;
      this.code = 4001;
      this.message = "The user rejected the request.";
    }
    UserRejectedRequest.prototype = Object.create(Error.prototype);

    function web3Response (payload, result){
        return {id: payload.id,
                jsonrpc: "2.0",
                result: result};
    }

    function getSyncResponse (payload) {
        if (payload.method == "eth_accounts" && (typeof statusAppcurrentAccountAddress !== "undefined")) {
            return web3Response(payload, [statusAppcurrentAccountAddress])
        } else if (payload.method == "eth_coinbase" && (typeof statusAppcurrentAccountAddress !== "undefined")) {
            return web3Response(payload, statusAppcurrentAccountAddress)
        } else if (payload.method == "eth_uninstallFilter"){
            return web3Response(payload, true);
        } else {
            return null;
        }
    }

    var StatusAPI = function () {};

    StatusAPI.prototype.getContactCode = function () {
        return sendAPIrequest('contact-code');
    };

    var EthereumProvider = function () {};

    EthereumProvider.prototype.isStatus = true;
    EthereumProvider.prototype.status = new StatusAPI();
    EthereumProvider.prototype.isConnected = function () { return true; };

    EthereumProvider.prototype.enable = function () {
        return sendAPIrequest('web3');
    };

    EthereumProvider.prototype.scanQRCode = function (regex) {
        return sendAPIrequest('qr-code', {regex: regex});
    };

    EthereumProvider.prototype.on = function (type, handler)
    {
        console.log("Not supported by Status")
    }

    EthereumProvider.prototype.request = function (requestArguments)
    {
         if (!requestArguments) {
           return new Error('Request is not valid.');
         }
         var method = requestArguments.method;

         if (!method) {
           return new Error('Request is not valid.');
         }

         //Support for legacy send method
         if (typeof method !== 'string') {
           return this.sendSync(method);
         }

         if (method == 'eth_requestAccounts'){
             return sendAPIrequest('web3');
         }

         var syncResponse = getSyncResponse({method: method});
         if (syncResponse){
             return new Promise(function (resolve, reject) {
                                        resolve(syncResponse.result);
                                    });
         }

         var messageId = callbackId++;
         var payload = {id:      messageId,
                        jsonrpc: "2.0",
                        method:  method,
                        params:  requestArguments.params};

         bridgeSend({type:      'web3-send-async-read-only',
                     messageId: messageId,
                     payload:   payload});

         return new Promise(function (resolve, reject) {
                                callbacks[messageId] = {beta:    true,
                                                        resolve: resolve,
                                                        reject:  reject};
                            });
    };

    // (DEPRECATED) Support for legacy send method
    EthereumProvider.prototype.send = function (method, params = [])
    {
        return this.request({method: method, params: params});
    }

    // (DEPRECATED) Support for legacy sendSync method
    EthereumProvider.prototype.sendSync = function (payload)
    {
        if (payload.method == "eth_uninstallFilter"){
            this.sendAsync(payload, function (res, err) {})
        }
        var syncResponse = getSyncResponse(payload);
        if (syncResponse){
            return syncResponse;
        } else {
            return web3Response(payload, null);
        }
    };

    // (DEPRECATED) Support for legacy sendAsync method
    EthereumProvider.prototype.sendAsync = function (payload, callback)
    {
      var syncResponse = getSyncResponse(payload);
      if (syncResponse && callback) {
          callback(null, syncResponse);
      }
      else
      {
          var messageId = callbackId++;

          if (Array.isArray(payload))
          {
              callbacks[messageId] = {num:      payload.length,
                                      results:  [],
                                      callback: callback};
              for (var i in payload) {
                  bridgeSend({type:      'web3-send-async-read-only',
                              messageId: messageId,
                              payload:   payload[i]});
              }
          }
          else
          {
              callbacks[messageId] = {callback: callback};
              bridgeSend({type:      'web3-send-async-read-only',
                          messageId: messageId,
                          payload:   payload});
          }
      }
    };
    EthereumProvider.prototype.onMessage = function (message)
        {
            data = JSON.parse(message);
            var id = data.messageId;
            var callback = callbacks[id];

            if (callback) {
                if (data.type === "api-response") {
                    if (data.permission == 'qr-code'){
                        qrCodeResponse(data, callback);
                    } else if (data.isAllowed) {
                        if (data.permission == 'web3') {
                            statusAppcurrentAccountAddress = data.data[0];
                        }
                        callback.resolve(data.data);
                    } else {
                        callback.reject(new UserRejectedRequest());
                    }
                }
                else if (data.type === "web3-send-async-callback")
                {
                    if (callback.beta)
                    {
                        if (data.error)
                        {
                            if (data.error.code == 4100)
                                callback.reject(new Unauthorized());
                            else
                                callback.reject(data.error);
                        }
                        else
                        {
                            callback.resolve(data.result.result);
                        }
                    }
                    else if (callback.results)
                    {
                        callback.results.push(data.error || data.result);
                        if (callback.results.length == callback.num)
                            callback.callback(undefined, callback.results);
                    }
                    else
                    {
                        callback.callback(data.error, data.result);
                    }
                }
            }
        };

    return new EthereumProvider();
    }